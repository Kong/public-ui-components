<template>
  <QueryDataProvider
    :context="context"
    :query="query"
    :query-ready="queryReady"
    :refresh-counter="refreshCounter"
    @chart-data="onChartData"
  >
    <AnalyticsGeoMap
      :bounds="chartOptions.bounds"
      :country-metrics="countryMetrics"
      :fit-to-country="chartOptions.fit_to_country"
      :metric="(countryMetric as ExploreAggregations)"
      :metric-unit="(countryMetricUnit as MetricUnits)"
      :with-legend="chartOptions.legend || false"
    />
  </QueryDataProvider>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import QueryDataProvider from './QueryDataProvider.vue'
import { AnalyticsGeoMap } from '@kong-ui-public/analytics-geo-map'
import type { MetricUnits } from '@kong-ui-public/analytics-geo-map'
import type { ChoroplethMapOptions, ExploreAggregations, ExploreResultV4 } from '@kong-ui-public/analytics-utilities'
import type { RendererProps } from '../types'
import '@kong-ui-public/analytics-geo-map/dist/style.css'

defineProps<RendererProps<ChoroplethMapOptions>>()

const chartDataRaw = ref<ExploreResultV4 | undefined>(undefined)

const countryMetrics = computed((): Record<string, number> => {
  if (!chartDataRaw.value) {
    return {}
  }

  const metrics = {} as Record<string, number>
  const data = chartDataRaw.value?.data

  if (data) {
    for (let row of data) {
      const countryKey = row?.event?.iso_code
      const metricKey = chartDataRaw.value?.meta.metric_names?.[0]

      if (countryKey) {
        metrics[countryKey] = metricKey ? row.event[metricKey] as number : 0
      }
    }
  }

  return metrics as any as Record<string, number>
})

const countryMetric = computed(() => {
  if (!chartDataRaw.value) {
    return ''
  }

  return chartDataRaw.value?.meta.metric_names && chartDataRaw.value.meta.metric_names[0]
})

const countryMetricUnit = computed(() => {
  if (!chartDataRaw.value) {
    return ''
  }

  const metricUnits = chartDataRaw?.value?.meta.metric_units
  const metricNames = chartDataRaw?.value?.meta?.metric_names

  return metricUnits && metricNames && metricUnits[metricNames[0]]
})

const onChartData = (data: ExploreResultV4) => {
  chartDataRaw.value = data
}

</script>
